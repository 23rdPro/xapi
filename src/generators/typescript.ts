// Convert OpenAPI schemas to TypeScript types.
// + Zod schema generation (validation at runtime)
// + JSDoc comments for better DX
import fs from "node:fs/promises";
import path from "node:path";
import type { Endpoint, GraphQLEndpoint } from "types/endpoint";
import type { TSGenOptions } from "types/generators";
import {
  makeTypeName,
  capitalize,
  jsonSchemaToTS,
  simpleSchemaToTS,
  schemaToZodCode,
} from "utils/generators";
/**
 * Covers primitives, arrays, and objects with properties (deep oneOf/anyOf).
 */
export async function generateTypes(
  endpoints: Endpoint[],
  opts: TSGenOptions = {}
): Promise<string> {
  const lines: string[] = [];
  lines.push("// AUTO-GENERATED by xapi â€” do not edit");
  lines.push("");
  const needZod = !!opts.zod;
  if (needZod) {
    lines.push(`import { z } from "zod";`);
    lines.push("");
  }
  // track declared/exported names to avoid duplicates
  const declaredNames = new Set<string>();
  // schemaHash -> exportedName (so same schema reuses the same declaration)
  // schemaKey -> { tsName, zodName? }
  const schemaMap = new Map<string, { tsName: string; zodName?: string }>();
  function uniqueName(base: string, declared: Set<string>) {
    let name = base;
    let i = 1;
    while (declared.has(name)) {
      name = `${base}_${i++}`;
    }
    declared.add(name);
    return name;
  }
  // stable stringify for schema hashing (sorts object keys)
  function stableStringify(obj: any): string {
    const seen = new WeakSet();
    function _stringify(value: any): any {
      if (value === null || typeof value !== "object") return value;
      if (seen.has(value)) return "__CIRCULAR__";
      seen.add(value);
      if (Array.isArray(value)) return value.map(_stringify);
      const keys = Object.keys(value).sort();
      const out: any = {};
      for (const k of keys) out[k] = _stringify(value[k]);
      return out;
    }
    return JSON.stringify(_stringify(obj));
  }

  async function emitSchema(
    schema: any,
    baseName: string,
    opts: { needZod: boolean },
    lines: string[],
    schemaMap: Map<string, { tsName: string; zodName?: string }>,
    declaredNames: Set<string>
  ): Promise<{ tsName: string; zodName?: string }> {
    if (!schema) {
      return { tsName: "any", zodName: opts.needZod ? "z.any()" : undefined };
    }
    const schemaKey = stableStringify(schema);
    const cached = schemaMap.get(schemaKey);
    if (cached) return cached;
    const candidateName = uniqueName(baseName, declaredNames);
    let tsName = candidateName;
    let zodName: string | undefined;

    const { code, exportedName } = await jsonSchemaToTS(schema, candidateName);
    if (code) {
      lines.push(code.trim());
      tsName = exportedName ?? candidateName;
    } else {
      // fallback simple mapping
      const ts = simpleSchemaToTS(schema, candidateName);
      lines.push(`export type ${candidateName} = ${ts};`);
      tsName = candidateName;
    }
    if (opts.needZod) {
      const zodVar = makeTypeName(tsName, "Schema");
      const zodCode = schemaToZodCode(schema, zodVar);
      lines.push(`export const ${zodVar} = ${zodCode};`);
      lines.push(
        `export type ${makeTypeName(tsName, "Parsed")} = z.infer<typeof ${zodVar}>;`
      );
      zodName = zodVar;
    }
    const result = { tsName, zodName };
    schemaMap.set(schemaKey, result);
    declaredNames.add(tsName);
    return result;
  }
  for (const ep of endpoints) {
    const baseRaw = opts.prefix ? `${opts.prefix}_${ep.name}` : ep.name;
    const base = baseRaw.replace(/[^a-zA-Z0-9_]/g, "_");
    const TypeBase = capitalize(base);
    // JSDoc header
    if (ep.summary || ep.description) {
      lines.push("/**");
      if (ep.summary) lines.push(` * ${ep.summary}`);
      if (ep.description) lines.push(` * ${ep.description}`);
      lines.push(" */");
    }
    // params -> combine path & query into an interface
    const paramsTypeName = `${TypeBase}Params`;
    if (ep.params && ep.params.length) {
      const propsObj: any = {
        type: "object",
        properties: {},
        required: [] as string[],
      };
      for (const p of ep.params) {
        propsObj.properties[p.name] = p.schema || { type: "any" };
        if (p.required) propsObj.required.push(p.name);
      }
      const { tsName } = await emitSchema(
        propsObj,
        paramsTypeName,
        { needZod },
        lines,
        schemaMap,
        declaredNames
      );
      if (tsName !== paramsTypeName) {
        lines.push(`export type ${paramsTypeName} = ${tsName};`);
      }
    } else {
      lines.push(`export type ${paramsTypeName} = void;`);
    }
    // request body
    const bodyTypeName = `${TypeBase}Body`;
    if (ep.requestBody && (ep.requestBody as any).schema) {
      const { tsName } = await emitSchema(
        (ep.requestBody as any).schema,
        bodyTypeName,
        { needZod },
        lines,
        schemaMap,
        declaredNames
      );
      if (tsName !== bodyTypeName) {
        lines.push(`export type ${bodyTypeName} = ${tsName};`);
      }
    } else {
      lines.push(`export type ${bodyTypeName} = void;`);
    }
    // Composite Request
    lines.push(
      `export type ${TypeBase}Request = ${paramsTypeName} & ${bodyTypeName};`
    );
    // Response: pick preferredResponse if present
    const respTypeName = `${TypeBase}Response`;
    const pref =
      (ep as any).preferredResponse || (ep.responses && ep.responses[0]);
    if (pref && (pref as any)?.schema) {
      const { tsName } = await emitSchema(
        (pref as any).schema,
        respTypeName,
        { needZod },
        lines,
        schemaMap,
        declaredNames
      );
      if (tsName !== respTypeName) {
        lines.push(`export type ${respTypeName} = ${tsName};`);
      }
    } else {
      lines.push(`export type ${respTypeName} = any;`);
      // Add Zod (optional)
      if (needZod) {
        lines.push(
          `export const ${makeTypeName(TypeBase, "ResponseSchema")} = z.any();`
        );
        lines.push(
          `export type ${makeTypeName(TypeBase, "ResponseParsed")} = any;`
        );
      }
    }
    lines.push("");
  }
  const out = lines.join("\n");
  if (opts.outputPath) {
    const dest = path.resolve(opts.outputPath);
    await fs.mkdir(path.dirname(dest), { recursive: true });
    await fs.writeFile(dest, out, "utf8");
  }
  return out;
}
/**
 * Generate GraphQL request/response types (and optional Zod schemas).
 * @param endpoints - Normalized GraphQL endpoints
 * @param opts - Options for generation
 * @returns Generated TypeScript string
 */
export async function generateGraphQLTypes(
  endpoints: GraphQLEndpoint[],
  opts: { outputPath?: string; prefix?: string; zod?: boolean } = {}
): Promise<string> {
  const prefix = opts.prefix ?? "GQL";
  let out = `// Auto-generated GraphQL types by xapi\n\n`;

  for (const ep of endpoints) {
    const opName = capitalize(ep.operationName);

    if (ep.requestSchema) {
      const reqTypeName = `${prefix}${opName}Request`;
      out += `export type ${reqTypeName} = ${simpleSchemaToTS(
        ep.requestSchema,
        reqTypeName
      )};\n\n`;
      if (opts.zod) {
        out += `export const ${reqTypeName}Schema = ${schemaToZodCode(
          ep.requestSchema,
          reqTypeName
        )};\n\n`;
      }
    } else {
      out += `export type ${prefix}${opName}Request = void;\n\n`;
    }
    if (ep.responseSchema) {
      const resTypeName = `${prefix}${opName}Response`;
      out += `export type ${resTypeName} = ${simpleSchemaToTS(
        ep.responseSchema,
        resTypeName
      )};\n\n`;
      if (opts.zod) {
        out += `export const ${resTypeName}Schema = ${schemaToZodCode(
          ep.responseSchema,
          resTypeName
        )};\n\n`;
      }
    } else {
      out += `export type ${prefix}${opName}Response = any;\n\n`;
    }
  }
  if (opts.outputPath) {
    const full = path.resolve(opts.outputPath);
    await fs.writeFile(full, out, "utf8");
  }
  return out;
}
