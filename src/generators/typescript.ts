// Convert OpenAPI schemas to TypeScript types.
// + Zod schema generation (validation at runtime)
// + JSDoc comments for better DX
import fs from "node:fs/promises";
import path from "node:path";
import type { Endpoint } from "types/endpoint";
import type { TSGenOptions } from "types/generators";
import {
  makeTypeName,
  capitalize,
  jsonSchemaToTS,
  simpleSchemaToTS,
  schemaToZodCode,
} from "utils/generators";
/**
 * Covers primitives, arrays, and objects with properties (deep oneOf/anyOf).
 */
export async function generateTypes(
  endpoints: Endpoint[],
  opts: TSGenOptions = {}
): Promise<string> {
  const lines: string[] = [];
  lines.push("// AUTO-GENERATED by xapi â€” do not edit");
  lines.push("");
  const needZod = !!opts.zod;
  if (needZod) {
    lines.push(`import { z } from "zod";`);
    lines.push("");
  }
  // track declared/exported names to avoid duplicates
  const declaredNames = new Set<string>();
  // schemaHash -> exportedName (so same schema reuses the same declaration)
  const schemaMap = new Map<string, string>();
  function uniqueName(base: string) {
    let name = base;
    let i = 1;
    while (declaredNames.has(name)) {
      name = `${base}_${i++}`;
    }
    declaredNames.add(name);
    return name;
  }
  // stable stringify for schema hashing (sorts object keys)
  function stableStringify(obj: any): string {
    const seen = new WeakSet();
    function _stringify(value: any): any {
      if (value === null || typeof value !== "object") return value;
      if (seen.has(value)) return "__CIRCULAR__";
      seen.add(value);
      if (Array.isArray(value)) return value.map(_stringify);
      const keys = Object.keys(value).sort();
      const out: any = {};
      for (const k of keys) out[k] = _stringify(value[k]);
      return out;
    }
    return JSON.stringify(_stringify(obj));
  }
  for (const ep of endpoints) {
    const baseRaw = opts.prefix ? `${opts.prefix}_${ep.name}` : ep.name;
    const base = baseRaw.replace(/[^a-zA-Z0-9_]/g, "_");
    const TypeBase = capitalize(base);
    // JSDoc header
    if (ep.summary || ep.description) {
      lines.push("/**");
      if (ep.summary) lines.push(` * ${ep.summary}`);
      if (ep.description) lines.push(` * ${ep.description}`);
      lines.push(" */");
    }
    // params -> combine path & query into an interface
    const paramsTypeName = `${TypeBase}Params`;
    if (ep.params && ep.params.length) {
      const propsObj: any = {
        type: "object",
        properties: {},
        required: [] as string[],
      };
      for (const p of ep.params) {
        propsObj.properties[p.name] = p.schema || { type: "any" };
        if (p.required) propsObj.required.push(p.name);
      }
      const schemaKey = stableStringify(propsObj);
      let exportedForSchema = schemaMap.get(schemaKey);
      // Try json-schema-to-typescript first
      // give json-schema-to-typescript a unique candidate name
      if (!exportedForSchema) {
        const candidateName = uniqueName(paramsTypeName);
        const { code: paramsCode, exportedName: paramsExported } =
          await jsonSchemaToTS(propsObj, candidateName);
        if (paramsCode) {
          lines.push(paramsCode.trim());
          const realExport = paramsExported ?? candidateName;
          schemaMap.set(schemaKey, realExport);
          // if compiled exported with a different name from conventional, create alias
          if (
            realExport !== paramsTypeName &&
            !declaredNames.has(paramsTypeName)
          ) {
            lines.push(`export type ${paramsTypeName} = ${realExport};`);
            declaredNames.add(paramsTypeName);
          } else {
            declaredNames.add(realExport);
          }
          exportedForSchema = realExport;
        } else {
          // fallback to simple
          const candidateName = uniqueName(paramsTypeName);
          const ts = simpleSchemaToTS(propsObj, candidateName);
          lines.push(`export type ${paramsTypeName} = ${ts};`);
          schemaMap.set(schemaKey, paramsTypeName);
          declaredNames.add(paramsTypeName);
          exportedForSchema = paramsTypeName;
        }
      } else {
        // previously generated identical schema; create alias if needed
        if (exportedForSchema !== paramsTypeName) {
          if (!declaredNames.has(paramsTypeName)) {
            lines.push(`export type ${paramsTypeName} = ${exportedForSchema};`);
            declaredNames.add(paramsTypeName);
          }
        }
      }
    } else {
      lines.push(`export type ${paramsTypeName} = void;`);
      declaredNames.add(paramsTypeName);
    }
    // request body
    const bodyTypeName = `${TypeBase}Body`;
    if (ep.requestBody && (ep.requestBody as any).schema) {
      const schema = (ep.requestBody as any).schema;
      const schemaKey = stableStringify(schema);
      let exportedForSchema = schemaMap.get(schemaKey);
      if (!exportedForSchema) {
        const candidateName = uniqueName(bodyTypeName);
        const { code: bodyCode, exportedName: bodyExported } =
          await jsonSchemaToTS(schema, candidateName);
        if (bodyCode) {
          lines.push(bodyCode.trim());
          const realExport = bodyExported ?? candidateName;
          schemaMap.set(schemaKey, realExport);
          if (realExport !== bodyTypeName && !declaredNames.has(bodyTypeName)) {
            lines.push(`export type ${bodyTypeName} = ${realExport};`);
            declaredNames.add(bodyTypeName);
          } else {
            declaredNames.add(realExport);
          }
          exportedForSchema = realExport;
        } else {
          const candidateName = uniqueName(bodyTypeName);
          const ts = simpleSchemaToTS(schema, candidateName);
          lines.push(`export type ${bodyTypeName} = ${ts};`);
          schemaMap.set(schemaKey, bodyTypeName);
          declaredNames.add(bodyTypeName);
          exportedForSchema = bodyTypeName;
        }
      } else {
        if (exportedForSchema !== bodyTypeName) {
          if (!declaredNames.has(bodyTypeName)) {
            lines.push(`export type ${bodyTypeName} = ${exportedForSchema};`);
            declaredNames.add(bodyTypeName);
          }
        }
      }
    } else {
      lines.push(`export type ${bodyTypeName} = void;`);
      declaredNames.add(bodyTypeName);
    }
    // Composite Request
    lines.push(
      `export type ${TypeBase}Request = ${paramsTypeName} & ${bodyTypeName};`
    );
    // Response: pick preferredResponse if present
    const respTypeName = `${TypeBase}Response`;
    const pref =
      (ep as any).preferredResponse || (ep.responses && ep.responses[0]);
    if (pref && (pref as any).schema) {
      const schema = (pref as any).schema;
      const schemaKey = stableStringify(schema);
      let exportedForSchema = schemaMap.get(schemaKey);
      if (!exportedForSchema) {
        const candidateName = uniqueName(respTypeName);
        const { code: respCode, exportedName: respExported } =
          await jsonSchemaToTS(schema, candidateName);
        if (respCode) {
          lines.push(respCode.trim());
          const realExport = respExported ?? candidateName;
          schemaMap.set(schemaKey, realExport);
          if (realExport !== respTypeName && !declaredNames.has(respTypeName)) {
            lines.push(`export type ${respTypeName} = ${realExport};`);
            declaredNames.add(respTypeName);
          } else {
            declaredNames.add(realExport);
          }
          exportedForSchema = realExport;
        } else {
          const candidateName = uniqueName(respTypeName);
          const ts = simpleSchemaToTS(schema, candidateName);
          lines.push(`export type ${respTypeName} = ${ts};`);
          schemaMap.set(schemaKey, respTypeName);
          declaredNames.add(respTypeName);
          exportedForSchema = respTypeName;
        }
      } else {
        if (exportedForSchema !== respTypeName) {
          if (!declaredNames.has(respTypeName)) {
            lines.push(`export type ${respTypeName} = ${exportedForSchema};`);
            declaredNames.add(respTypeName);
          }
        }
      }
      // Add Zod (optional)
      if (needZod) {
        const zodCode = schemaToZodCode(schema, `${TypeBase}Response`);
        lines.push(
          `export const ${makeTypeName(TypeBase, "ResponseSchema")} = ${zodCode};`
        );
        lines.push(
          `export type ${makeTypeName(TypeBase, "ResponseParsed")} = z.infer<typeof ${makeTypeName(TypeBase, "ResponseSchema")}>;`
        );
      }
    } else {
      lines.push(`export type ${respTypeName} = any;`);
      if (needZod) {
        lines.push(
          `export const ${makeTypeName(TypeBase, "ResponseSchema")} = z.any();`
        );
        lines.push(
          `export type ${makeTypeName(TypeBase, "ResponseParsed")} = any;`
        );
      }
      declaredNames.add(respTypeName);
    }
    lines.push("");
  }
  const out = lines.join("\n");
  if (opts.outputPath) {
    const dest = path.resolve(opts.outputPath);
    await fs.mkdir(path.dirname(dest), { recursive: true });
    await fs.writeFile(dest, out, "utf8");
  }
  return out;
}
