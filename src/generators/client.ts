// Use the normalized endpoint list to generate:
// fetch (default)
// axios (optional)
// RTK Query endpoint factory (optional)
// and tanstack
import fs from "node:fs/promises";
import path from "node:path";
import type { Endpoint } from "types/endpoint";
import type { ClientGenOptions } from "types/generators";
import { capitalize } from "utils/generators";

function makePathTemplate(ep: Endpoint): string {
  return "`" + ep.path.replace(/{(.*?)}/g, "${params.$1}") + "`";
}

export async function generateClient(
  endpoints: Endpoint[],
  opts: ClientGenOptions = {}
): Promise<string> {
  const lines: string[] = [];
  lines.push("// AUTO-GENERATED by xapi â€” do not edit");
  lines.push("");
  lines.push(`import type {`);
  for (const ep of endpoints) {
    const funcName = ep.name;
    const paramsType = `${capitalize(funcName)}Params`;
    const respType = `${capitalize(funcName)}Response`;
    lines.push(`  ${paramsType},`);
    lines.push(`  ${respType},`);
  }
  lines.push(`} from "./types";`);
  lines.push("");
  const baseUrl = opts.baseUrl ?? "";
  lines.push(`const BASE_URL = "${baseUrl}";`);
  lines.push("");
  // add ApiError type
  lines.push(
    `export interface ApiError extends Error { status: number; body?: any }`
  );
  lines.push("");
  switch (opts.httpLibrary) {
    case "axios":
      lines.push(`import axios from "axios";`);
      lines.push("");
      lines.push(`export const client = {`);
      lines.push(
        `  async request<T>(opts: { method: string; path: string; body?: any }): Promise<T> {`
      );
      lines.push(`    try {`);
      lines.push(
        `      const res = await axios.request<T>({ url: BASE_URL + opts.path, method: opts.method, data: opts.body });`
      );
      lines.push(`      return res.data;`);
      lines.push(`    } catch (e: any) {`);
      lines.push(`      const err = new Error(e.message) as ApiError;`);
      lines.push(`      err.status = e.response?.status ?? 500;`);
      lines.push(`      err.body = e.response?.data;`);
      lines.push(`      throw err;`);
      lines.push(`    }`);
      lines.push(`  }`);
      lines.push(`};`);
      break;
    case "rtk":
      lines.push(
        `import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";`
      );

      lines.push("");
      lines.push(`export const api = createApi({`);
      lines.push(`  reducerPath: "xapi",`);
      lines.push(`  baseQuery: fetchBaseQuery({ baseUrl: BASE_URL }),`);
      lines.push(`  endpoints: (builder) => ({`);
      for (const ep of endpoints) {
        const funcName = ep.name;
        const paramsType = `${capitalize(funcName)}Params`;
        const respType = `${capitalize(funcName)}Response`;
        const needsParams = ep.path.includes("{") || ep.requestBody;
        const method = ep.method.toLowerCase();
        const builderMethod = method === "get" ? "query" : "mutation";
        lines.push(
          `    ${funcName}: builder.${builderMethod}<${respType}, ${needsParams ? paramsType : "void"}>({`
        );
        // template substitution
        if (needsParams) {
          lines.push(`      query: (params: ${paramsType}) => ({`);
        } else {
          lines.push(`      query: () => ({`);
        }
        lines.push(`        url: ${makePathTemplate(ep)},`);
        lines.push(`        method: "${ep.method}",`);
        if (ep.requestBody) {
          lines.push(`        body: params,`);
        }
        lines.push(`      }),`);
        lines.push(`    }),`);
      }
      lines.push(`  })`);
      lines.push(`});`);
      lines.push("");
      lines.push(`export const {`);
      for (const ep of endpoints) {
        lines.push(
          `  use${capitalize(ep.name)}${ep.method.toLowerCase() === "get" ? "Query" : "Mutation"},`
        );
      }
      lines.push(`} = api;`);
      break;
    case "tanstack":
      lines.push(
        `import { useQuery, useMutation } from "@tanstack/react-query";`
      );
      lines.push("");
      lines.push(
        `async function rawRequest<T>(opts: { method: string; path: string; body?: any }): Promise<T> {`
      );
      lines.push(`  const res = await fetch(BASE_URL + opts.path, {`);
      lines.push(`    method: opts.method,`);
      lines.push(`    headers: { "Content-Type": "application/json" },`);
      lines.push(
        `    body: opts.body ? JSON.stringify(opts.body) : undefined,`
      );
      lines.push(`  });`);
      lines.push(`  if (!res.ok) {`);
      lines.push(
        `    const err = new Error(\`HTTP \${res.status}\`) as ApiError;`
      );
      lines.push(`    err.status = res.status;`);
      lines.push(`    try { err.body = await res.json(); } catch {}`);
      lines.push(`    throw err;`);
      lines.push(`  }`);
      lines.push(`  return (await res.json()) as T;`);
      lines.push(`}`);
      lines.push("");

      for (const ep of endpoints) {
        const funcName = ep.name;
        const paramsType = `${capitalize(funcName)}Params`;
        const respType = `${capitalize(funcName)}Response`;
        const needsParams = ep.path.includes("{") || ep.requestBody;
        const hookName = `use${capitalize(funcName)}`;
        const pathExpr =
          "`" + ep.path.replace(/{(.*?)}/g, "${params.$1}") + "`";

        if (ep.method.toLowerCase() === "get") {
          if (needsParams) {
            // params required
            lines.push(`export function ${hookName}(params: ${paramsType}) {`);
          } else {
            // no params
            lines.push(`export function ${hookName}() {`);
          }

          lines.push(`  return useQuery<${respType}>({`);
          lines.push(
            `    queryKey: ["${funcName}"${needsParams ? ", params" : ""}],`
          );
          lines.push(
            `    queryFn: () => rawRequest<${respType}>({ method: "get", path: ${pathExpr}${needsParams ? "" : ""} }),`
          );
          lines.push(`  });`);
          lines.push(`}`);
        } else {
          lines.push(`export function ${hookName}() {`);
          lines.push(
            `  return useMutation<${respType}, ApiError, ${paramsType}>({`
          );
          lines.push(
            `    mutationFn: (params) => rawRequest<${respType}>({ method: "${ep.method}", path: ${pathExpr}, body: params }),`
          );
          lines.push(`  });`);
          lines.push(`}`);
        }
        lines.push("");
      }
      break;
    case "fetch":
    default:
      lines.push(`// Default client using fetch`);
      lines.push(`export const client = {`);
      lines.push(
        `  async request<T>(opts: { method: string; path: string; body?: any }): Promise<T> {`
      );
      lines.push(`    const res = await fetch(BASE_URL + opts.path, {`);
      lines.push(`      method: opts.method,`);
      lines.push(`      headers: { "Content-Type": "application/json" },`);
      lines.push(
        `      body: opts.body ? JSON.stringify(opts.body) : undefined,`
      );
      lines.push(`    });`);
      lines.push(`    if (!res.ok) {`);
      lines.push(`      const baseError = new Error(\`HTTP \${res.status}\`);`);
      lines.push(`      const err = baseError as ApiError;`);
      lines.push(`      err.status = res.status;`);
      lines.push(`      try {`);
      lines.push(`        const data = await res.json();`);
      lines.push(`        err.body = data;`);
      lines.push(`      } catch {`);
      lines.push(`        // ignore if body is not JSON`);
      lines.push(`      }`);
      lines.push(`      throw err;`);
      lines.push(`    }`);
      lines.push(``);
      lines.push(`    return (await res.json()) as T;`);
      lines.push(`  }`);
      lines.push(`};`);
      break;
  }
  if (!["rtk", "tanstack"].includes(opts.httpLibrary ?? "fetch")) {
    lines.push("");
    for (const ep of endpoints) {
      const funcName = ep.name;
      const paramsType = `${capitalize(funcName)}Params`;
      const respType = `${capitalize(funcName)}Response`;
      const needsParams = ep.path.includes("{") || ep.requestBody;
      const bodyArg = needsParams
        ? "params: " + paramsType
        : "params?: " + paramsType;
      // Function signature
      lines.push(
        `export async function ${funcName}(${bodyArg}): Promise<${respType}> {`
      );
      let pathExpr = "`" + ep.path.replace(/{(.*?)}/g, "${params.$1}") + "`";
      lines.push(`  return client.request<${respType}>({`);
      lines.push(`    method: "${ep.method}",`);
      lines.push(`    path: ${pathExpr},`);
      if (ep.requestBody) {
        lines.push(`    body: params,`);
      }
      lines.push(`  });`);
      lines.push(`}`);
      lines.push("");
    }
  }
  const out = lines.join("\n");
  if (opts.outputPath) {
    const dest = path.resolve(opts.outputPath);
    await fs.mkdir(path.dirname(dest), { recursive: true });
    await fs.writeFile(dest, out, "utf8");
  }
  return out;
}
