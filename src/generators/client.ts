// Use the normalized endpoint list to generate:
// fetch (default)
// axios (optional)
// RTK Query endpoint factory (optional)
// and tanstack
import fs from "node:fs/promises";
import path from "node:path";
import type { Endpoint, GraphQLEndpoint } from "types/endpoint";
import type { ClientGenOptions } from "types/generators";
import { capitalize, makePathTemplate, toApiError } from "utils/generators";

export async function generateClient(
  endpoints: Endpoint[],
  opts: ClientGenOptions = {}
): Promise<string> {
  const lines: string[] = [];
  lines.push("// AUTO-GENERATED by xapi â€” do not edit");
  lines.push("");
  lines.push(`import type {`);
  for (const ep of endpoints) {
    const funcName = capitalize(ep.name);
    const paramsType = `${funcName}Params`;
    const respType = `${funcName}Response`;
    lines.push(`  ${paramsType},`);
    lines.push(`  ${respType},`);
  }
  lines.push(`} from "./types";\n`);
  const baseUrl = opts.baseUrl ?? "";
  lines.push(`const BASE_URL = "${baseUrl}";`);
  lines.push("");
  // add ApiError type
  lines.push(
    `export interface ApiError extends Error { status: number; body?: any }\n`
  );
  switch (opts.httpLibrary) {
    case "axios":
      lines.push(`import axios from "axios";\n`);
      lines.push(`export const client = {`);
      lines.push(
        `  async request<T>(opts: { method: string; path: string; body?: any }): Promise<T> {`
      );
      lines.push(`    try {`);
      lines.push(
        `      const res = await axios.request<T>({ url: BASE_URL + opts.path, method: opts.method, data: opts.body });`
      );
      lines.push(`      return res.data;`);
      lines.push(`    } catch (e: any) {`);
      lines.push(toApiError("e"));
      lines.push(`    }`);
      lines.push(`  }`);
      lines.push(`};`);
      break;
    case "rtk":
      lines.push(
        `import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";\n`
      );
      lines.push(`export const api = createApi({`);
      lines.push(`  reducerPath: "xapi",`);
      lines.push(`  baseQuery: fetchBaseQuery({ baseUrl: BASE_URL }),`);
      lines.push(`  endpoints: (builder) => ({`);
      for (const ep of endpoints) {
        const funcName = ep.name;
        const paramsType = `${capitalize(funcName)}Params`;
        const respType = `${capitalize(funcName)}Response`;
        const needsParams = ep.path.includes("{") || ep.requestBody;
        const method = ep.method.toLowerCase();
        const builderMethod = method === "get" ? "query" : "mutation";
        lines.push(
          `    ${funcName}: builder.${builderMethod}<${respType}, ${needsParams ? paramsType : "void"}>({`
        );
        // template substitution
        if (needsParams) {
          lines.push(`      query: (params: ${paramsType}) => ({`);
        } else {
          lines.push(`      query: () => ({`);
        }
        lines.push(`        url: ${makePathTemplate(ep)},`);
        lines.push(`        method: "${ep.method}",`);
        if (ep.requestBody) {
          lines.push(`        body: params,`);
        }
        lines.push(`      }),`);
        lines.push(`    }),`);
      }
      lines.push(`  })`);
      lines.push(`});`);
      lines.push("");
      lines.push(`export const {`);
      for (const ep of endpoints) {
        lines.push(
          `  use${capitalize(ep.name)}${ep.method.toLowerCase() === "get" ? "Query" : "Mutation"},`
        );
      }
      lines.push(`} = api;`);
      break;
    case "tanstack":
      lines.push(
        `import { useQuery, useMutation } from "@tanstack/react-query";\n`
      );
      lines.push(
        `async function rawRequest<T>(opts: { method: string; path: string; body?: any }): Promise<T> {`
      );
      lines.push(`  const res = await fetch(BASE_URL + opts.path, {`);
      lines.push(`    method: opts.method,`);
      lines.push(`    headers: { "Content-Type": "application/json" },`);
      lines.push(
        `    body: opts.body ? JSON.stringify(opts.body) : undefined,`
      );
      lines.push(`  });`);
      lines.push(`  if (!res.ok) {`);
      lines.push(
        `    const err = new Error(\`HTTP \${res.status}\`) as ApiError;`
      );
      lines.push(`    err.status = res.status;`);
      lines.push(`    try { err.body = await res.json(); } catch {}`);
      lines.push(`    throw err;`);
      lines.push(`  }`);
      lines.push(`  return (await res.json()) as T;`);
      lines.push(`}`);
      lines.push("");

      for (const ep of endpoints) {
        const funcName = ep.name;
        const paramsType = `${capitalize(funcName)}Params`;
        const respType = `${capitalize(funcName)}Response`;
        const needsParams = ep.path.includes("{") || ep.requestBody;
        const hookName = `use${capitalize(funcName)}`;
        const pathExpr =
          "`" + ep.path.replace(/{(.*?)}/g, "${params.$1}") + "`";

        if (ep.method.toLowerCase() === "get") {
          if (needsParams) {
            // params required
            lines.push(`export function ${hookName}(params: ${paramsType}) {`);
          } else {
            lines.push(`export function ${hookName}() {`);
          }

          lines.push(`  return useQuery<${respType}>({`);
          lines.push(
            `    queryKey: ["${funcName}"${needsParams ? ", params" : ""}],`
          );
          lines.push(
            `    queryFn: () => rawRequest<${respType}>({ method: "get", path: ${pathExpr}${needsParams ? "" : ""} }),`
          );
          lines.push(`  });`);
          lines.push(`}`);
        } else {
          lines.push(`export function ${hookName}() {`);
          lines.push(
            `  return useMutation<${respType}, ApiError, ${paramsType}>({`
          );
          lines.push(
            `    mutationFn: (params) => rawRequest<${respType}>({ method: "${ep.method}", path: ${pathExpr}, body: params }),`
          );
          lines.push(`  });`);
          lines.push(`}`);
        }
        lines.push("");
      }
      break;
    case "fetch":
    default:
      lines.push(`// Default client using fetch`);
      lines.push(`export const client = {`);
      lines.push(
        `  async request<T>(opts: { method: string; path: string; body?: any }): Promise<T> {`
      );
      lines.push(`    const res = await fetch(BASE_URL + opts.path, {`);
      lines.push(`      method: opts.method,`);
      lines.push(`      headers: { "Content-Type": "application/json" },`);
      lines.push(
        `      body: opts.body ? JSON.stringify(opts.body) : undefined,`
      );
      lines.push(`    });`);
      lines.push(`    if (!res.ok) {`);
      lines.push(`      const baseError = new Error(\`HTTP \${res.status}\`);`);
      lines.push(`      const err = baseError as ApiError;`);
      lines.push(`      err.status = res.status;`);
      lines.push(`      try {`);
      lines.push(`        const data = await res.json();`);
      lines.push(`        err.body = data;`);
      lines.push(`      } catch {`);
      lines.push(`        // ignore if body is not JSON`);
      lines.push(`      }`);
      lines.push(`      throw err;`);
      lines.push(`    }`);
      lines.push(``);
      lines.push(`    return (await res.json()) as T;`);
      lines.push(`  }`);
      lines.push(`};`);
      break;
  }
  if (!["rtk", "tanstack"].includes(opts.httpLibrary ?? "fetch")) {
    lines.push("");
    for (const ep of endpoints) {
      const funcName = ep.name;
      const paramsType = `${capitalize(funcName)}Params`;
      const respType = `${capitalize(funcName)}Response`;
      const needsParams = ep.path.includes("{") || ep.requestBody;
      const bodyArg = needsParams
        ? "params: " + paramsType
        : "params?: " + paramsType;
      // Function signature
      lines.push(
        `export async function ${funcName}(${bodyArg}): Promise<${respType}> {`
      );
      let pathExpr = "`" + ep.path.replace(/{(.*?)}/g, "${params.$1}") + "`";
      lines.push(`  return client.request<${respType}>({`);
      lines.push(`    method: "${ep.method}",`);
      lines.push(`    path: ${pathExpr},`);
      if (ep.requestBody) {
        lines.push(`    body: params,`);
      }
      lines.push(`  });`);
      lines.push(`}`);
      lines.push("");
    }
  }
  const out = lines.join("\n");
  if (opts.outputPath) {
    const dest = path.resolve(opts.outputPath);
    await fs.mkdir(path.dirname(dest), { recursive: true });
    await fs.writeFile(dest, out, "utf8");
  }
  return out;
}
export async function generateGraphQLClient(
  endpoints: GraphQLEndpoint[],
  opts: {
    outputPath?: string;
    baseUrl?: string;
    wsUrl?: string;
    zod?: boolean;
    prefix?: string;
  } = {}
): Promise<string> {
  const baseUrl = opts.baseUrl ?? "/graphql";
  const wsUrl = opts.wsUrl ?? "ws://localhost:4000/graphql";
  const prefix = opts.prefix ?? "GQL";

  let output = `// Auto-generated GraphQL client by xapi\n\n`;
  output += `import { ${endpoints
    .map((ep) => {
      const opName = capitalize(ep.operationName);
      return `${prefix}${opName}Request, ${prefix}${opName}Response${
        opts.zod
          ? `, ${prefix}${opName}RequestSchema, ${prefix}${opName}ResponseSchema`
          : ""
      }`;
    })
    .join(",\n  ")} } from "./types";\n\n`;
  // core client class
  output += `export class GraphQLClient {
    constructor(private url: string = "${baseUrl}") {}

    async request<TData, TVariables = Record<string, any>>(
      query: string,
      variables?: TVariables
    ): Promise<TData> {
      const res = await fetch(this.url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ query, variables }),
      });
      if (!res.ok) throw new Error(\`GraphQL request failed: \${res.status}\`);
      const json = await res.json();
      if (json.errors) throw new Error(JSON.stringify(json.errors));
      return json.data as TData;
    }
  }\n\n`;
  // ---- WS subscription client ----
  output += `export class GraphQLWebSocketClient {
    private socket: WebSocket;
    private idCounter = 1;
    private subscriptions = new Map<number, (data: any) => void>();

    constructor(url: string = "${wsUrl}") {
      this.socket = new WebSocket(url, "graphql-ws");
      this.socket.onopen = () => {
        this.socket.send(JSON.stringify({ type: "connection_init" }));
      };
      this.socket.onmessage = (event) => {
        const msg = JSON.parse(event.data);
        if (msg.id && this.subscriptions.has(Number(msg.id))) {
          this.subscriptions.get(Number(msg.id))?.(msg.payload.data);
        }
      };
    }
    subscribe(query: string, onData: (data: any) => void, variables?: Record<string, any> | undefined) {
      const id = this.idCounter++;
      this.subscriptions.set(id, onData);
      this.socket.send(JSON.stringify({
        id: String(id),
        type: "start",
        payload: { query, variables },
      }));
      return () => {
        this.socket.send(JSON.stringify({ id: String(id), type: "stop" }));
        this.subscriptions.delete(id);
      };
    }
  }\n\n`;
  // generate per-operation helpers
  for (const ep of endpoints) {
    const fnName = capitalize(ep.operationName);
    const queryDoc = ep.rawDocument?.trim() ?? "";
    const reqType = `${prefix}${fnName}Request`;
    const resType = `${prefix}${fnName}Response`;
    const reqSchema = `${reqType}Schema`;
    const resSchema = `${resType}Schema`;
    if (ep.operationType === "query" || ep.operationType === "mutation") {
      const kind = ep.operationType === "query" ? "Query" : "Mutation";
      if (opts.zod) {
        output += `export async function ${fnName}${kind}Validated(
          client: GraphQLClient,
          variables?: ${reqType}
        ): Promise<${resType}> {
          ${reqSchema}.parse(variables);
          const query = \`${queryDoc}\`;
          const data = await client.request<${resType}, ${reqType}>(query, variables);
          return ${resSchema}.parse(data);
        }\n\n`;
      }
      output += `export async function ${fnName}${kind}(
        client: GraphQLClient,
        variables?: ${reqType}
      ): Promise<${resType}> {
        const query = \`${queryDoc}\`;
        return client.request<${resType}, ${reqType}>(query, variables);
      }\n\n`;
    }
    if (ep.operationType === "subscription") {
      const hasVars = !!ep.requestSchema;
      if (opts.zod && hasVars) {
        output += `export function ${fnName}SubscriptionValidated(
          client: GraphQLWebSocketClient,
          variables: ${reqType},
          onData: (data: ${resType}) => void
        ) {
          ${reqSchema}.parse(variables);
          const query = \`${queryDoc}\`;
          return client.subscribe(query, variables, (raw) => {
            onData(${resSchema}.parse(raw));
          });
        }\n\n`;
      }
      if (hasVars) {
        output += `export function ${fnName}Subscription(
          client: GraphQLWebSocketClient,
          variables: ${reqType},
          onData: (data: ${resType}) => void
        ) {
          const query = \`${queryDoc}\`;
          return client.subscribe(query, variables, onData);
        }\n\n`;
      } else {
        output += `export function ${fnName}Subscription(
          client: GraphQLWebSocketClient,
          onData: (data: ${resType}) => void
        ) {
          const query = \`${queryDoc}\`;
          return client.subscribe(query, onData);
        }\n\n`;
      }
    }
  }
  if (opts.outputPath) {
    const full = path.resolve(opts.outputPath);
    await fs.writeFile(full, output, "utf8");
  }
  return output;
}
